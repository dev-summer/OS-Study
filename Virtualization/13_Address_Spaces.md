# 13 Address Spaces

## 13.2 Multiprogramming and Time Sharing

**multiprogramming**: 어떤 프로세스가 I/O를 수행하기로 하면, 다른 프로세스로 전환해서 CPU의 활용률(utilization)을 높이고, 효율성을 높일 수 있었다 (특히 기계가 비쌌던 시절에).

**time sharing**
- 메모리를 한 프로세스가 전부 잠깐동안 사용한 후 그 프로세스의 모든 상태를 디스크에 저장하고 -> 다른 프로세스의 상태를 전부 로드해서 실행하고 하는 방식은 너무 느리다는 문제점이 있었다.
- 레지스터 레벨의 상태(Program Counter 등)를 저장하고 복원하는 것은 상대적으로 빠르지만, 메모리의 모든 콘텐츠를 디스크에 저장하는 것은 성능이 좋지 않기 때문에, 프로세스를 전환할 때 프로세스를 메모리에 남겨두어서 OS가 time sharing을 효율적으로 구현할 수 있도록 한다.
    ![](https://i.imgur.com/I8GNsce.png)
    - 여러 개의 프로그램이 메모리에 동시적으로(concurrently) 머무르게 하면, **protection**을 신경써야 한다. 어떤 프로세스가 다른 프로세스의 메모리를 읽거나 그 메모리에 쓸 수 있어서는 안 된다.

## 13.3 The Address Space

OS가 물리적인 메모리를 추상화(abstraction)하는 것을 **address space**라고 한다.
**address space**: running program's view of memory in the system
- 어떤 프로세스의 주소 공간은 실행 중인 프로그램의 메모리 상태(memory state)를 전부 포함하고 있다.
    - 예: 프로그램 코드는 메모리 어딘가에 있어야 하기 때문에 주소 공간 안에 있다.
- 프로그램은 실행 중일 때, **스택**을 사용해서 함수 호출 체인의 어디에 위치해있는지를 추적하고, 지역 변수를 할당하고, 매개변수와 반환값을 전달한다.
- **힙**은 동적으로 할당되는, 유저가 관리하는 메모리에 사용된다.

![](https://i.imgur.com/p563TM4.png)
- 프로그램 코드: 주소 공간 가장 위쪽(낮은 주소값)에 위치.
    - 코드는 정적이기 때문에 메모리에 place시키기 쉬워서 주소 공간의 가장 위에 둔다. 프로그램이 실행되도 더 이상의 공간을 요구하지 않을 것이기 때문이다.
- 힙/스택이 차지하는 공간은 프로그램이 실행되면서 커지거나 작아질 수 있다.
- 힙: 코드 공간 바로 다음에 시작해서, 아래쪽으로 커진다.
- 스택: 주소 공간 가장 아래쪽(높은 주소값)에서 시작해서 위로 커진다.
- 여러 개의 스레드가 주소 공간에 공존할 경우, 무조건 힙은 위부터 아래 / 스택은 아래부터 위 로 나눌 수 없게 된다.
- 이 주소값은 프로그램은 실제로는 메모리의 물리적인 주소에 낮은 주소부터 높은 주소까지 할당되지 않고, 임의적인 물리적 주소에서 로드된다.
- 이걸 **OS가 메모리를 가상화한다**고 한다.
    - 실행 중인 프로그램이 자기가 특정한 주소의 메모리에 로드되었다고 생각하고, 굉장히 큰 주소 공간을 가질 수 있다고 생각하기 때문이다. 

## 13.4 Goals

OS가 메모리를 가상화 할 때, 어떻게 해야 하는가? 다음과 같은 목표들이 있다.

**transparency**
- OS는 가상 메모리를 실행중인 프로그램이 알 수 없게(invisible) 구현해야 한다.
    - 프로그램은 메모리가 가상화되었다는 사실을 몰라야 한다.
    - 프로그램은 자기가 private한 물리적인 메모리를 가지고 있다고 생각한다.

**efficiency**
- OS는 가상화를 최대한 효율적으로 해야한다.
    - 시간 효율성(프로그램이 더 느리게 실행되게 해서는 안 된다)
        - 시간 효율성이 높은 가상화를 구현하기 위해서는 OS는 TLB(Translation Lookaside Buffer)와 같은 하드웨어의 지원이 필요하다.
    - 공간 효율성(가상화를 위해 메모리 공간을 너무 많이 사용해서는 안 된다)

**protection**
- OS는 프로세스를 서로에게서 보호하고, 프로세스로부터 OS 자신을 보호해야 한다.
    - 한 프로세스가 load, store, 또는 instruction fetch를 수행할 때 다른 프로세스의 메모리에 접근하거나 영향을 미쳐서는 안 되고, OS에 영향을 미쳐서도 안 된다.
    - 프로세스간에 **isolation**을 가능하게 한다.
        - 메모리 isolation을 사용해서 OS는 실행 중인 프로세스가 다른 프로세스나 OS의 작업에 영향을 미치지 못하도록 한다.

## 13.5 Summary

가상 메모리: 프로그램에게 넓은 private한 주소 공간을 가지고 있다는 환상을 제공하고, 그 주소 공간에서 프로그램의 instruction과 데이터를 가지고 있게 한다.
OS는 가상 메모리에 대한 참조를 물리 주소로 변환할 수 있고, 물리 주소는 물리 메모리에서 원하는 정보를 가져오기 위해 사용된다. OS는 많은 프로세스들에 이 작업을 동시에 수행하고, 프로그램들을 다른 프로그램에게서 보호하면서, OS를 프로그램에게서 보호한다.
