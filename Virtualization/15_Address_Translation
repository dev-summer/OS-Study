# 15 Address Translation

**Limited Direct Execution(LDE)**: 대부분의 경우 프로그램을 하드웨어에서 직접적으로 실행하지만, 특정 지점(프로세스가 시스템 콜을 발행하거나 타이머 인터럽트가 발생한 경우) OS가 끼어들어서 제대로 된 작업이 일어나도록 한다.
- OS는 저런 특정 지점에 끼어들어서 하드웨어에 대한 컨트롤을 OS가 유지한다.

메모리를 가상화 할 때에도 유사한 전략을 사용해서 효율성과 컨트롤을 모두 잡는다.
- 효율성: 하드웨어 자원을 얼마나 사용하는가
- 컨트롤: OS는 모든 애플리케이션의 자신의 메모리에만 접근이 허용되도록 한다.
- 유연성(flexibility): 프로그램이 자신의 주소 공간을 사용하고 싶은 방식대로 사용하게 하는 것

→ 효율적이고 유연하게 메모리를 가상화하기
- 어떻게 하면 효율적으로 메모리를 가상화 할 수 있을까?
- 어떻게 하면 앱에서 필요로 하는 유연성을 제공할 수 있을까?
- 앱이 접근할 수 있는 메모리 장소에 대한 컨트롤을 어떻게 유지할 것이며, 메모리 접근이 적절하게 제한되어 있는지 어떻게 보장할 수 있는가?
- 이 모든 것을 어떻게 하면 효율적으로 할 수 있을까?

LDE 접근 방식에 추가로 **hardware-based address translation(address translation)**을 고려해 볼 수 있다.
- address translation을 사용하면 하드웨어는 각 메모리 접근을 변환하는데, instruction에서 제공된 가상 주소를 원하는 정보가 실제로 위치한 물리 주소로 변환한다. 그러므로 메모리 참조가 발생하면 하드웨어는 메모리 상의 실제 위치로 앱의 메모리 참조를 redirect하기 위해 주소 변환을 실행한다.

## 15.1 Assumptions
사용자의 주소 공간이 물리 메모리에서 연속적으로 위치해야만 한다고 가정.
주소 공간의 크기가 그렇게 크지 않다고 가정 (물리 메모리 크기보다 작다고 가정).
각 주소 공간의 사이즈가 같다고 가정.

## 15.2 An Example
메모리에서 값을 로드해서 값에 +3을 하고 다시 메모리에 값을 저장하는 예시
프로세스에 할당된 메모리 주소가 0부터 시작하는 것처럼 프로세스가 인지하게 하는 것이 메모리 가상화
그럼 실제 메모리 주소의 어디에 할당할 것인가??

## 15.3 Dynamic(Hardware-based) Relocation
**Dynamic Relocation(Base and Bounds)**
- CPU 내에 두 개의 하드웨어 레지스터가 필요하다: base register, bounds register(limit register)
    - 물리 메모리 내에 주소 공간을 위치시킬 수 있도록 해주고, 프로세스가 자기 자신의 주소 공간에만 접근할 수 있도록 해준다.
- 이 환경에서는 각 프로그램은 마치 자신이 0번 어드레스에 로드된 것처럼 쓰여지고 컴파일 된다. 하지만 프로그램이 실행되기 시작하면, OS는 물리 메모리의 어디에 프로그램이 로드되어야 하는지 결정하고, 베이스 레지스터를 해당 값으로 설정한다.
- 프로세스가 실행되면, 프로세스에 의해 발생한 모든 메모리 참조는 프로세서에 의해 `물리 주소 = 가상 주소 + base`의 방식으로 변환된다.
    - 프로세스에 의해 생성되는 모든 메모리 참조는 가상 주소이고, 베이스 레지스터에 콘텐츠를 더한 값이 물리 주소이다.
    - 프로그램 카운터(PC)의 값이 128이면, 베이스 레지스터 값에 PC값을 더해서 물리 주소를 구한다.
    - 프로세스가 가상 주소에서 15KB의 로드를 요청하면, 프로세스서는 베이스 레지스터에 15KB를 더해 물리 주소를 얻는다. 
    - 가상 주소를 물리 주소로 변환하는 것을 **주소 변환(address translation)**이라고 한다.
    - 주소를 변환하는 과정이 런타임에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동시킬 수 있기 때문에 이런 방식을 **dynamic relocation**이라고 한다.
- bounds는 주소 공간을 제한하는 역할을 한다.
    - 프로세스가 다른 프로세스의 메모리 주소에 접근하지 못하도록
    - bounds는 두 가지 방법으로 정의할 수 있다.
        - 주소 공간의 크기를 가지고 있어서, 하드웨어가 base register에 가상 주소를 더하기 전에 bounds register와 가상 주소를 비교한다.
        - 주소 공간의 끝에 해당하는 물리 주소를 가지고 있어서, 하드웨어가 base register에 가상 주소를 더한 후 bounds register 범위 내에 있는지 확인한다.
- base register와 bounds register는 칩에 존재하는 하드웨어 구조이다 (CPU 하나당 1쌍씩).
    - 주소 변환을 도와주는 프로세서 부분을 **memory management unit(MMU)**라고 부르기도 한다.

## 15.4 Hardware Support
하드웨어에서 지원해줘야 하는 것들
1. 두 가지의 CPU 모드
    - 커널 모드(또는 privileged mode)와 유저 모드
    - 프로세서 상태를 나타내는 단어로 저장된 하나의 비트는 CPU가 현재 어떤 모드로 실행되고 있는지를 알려준다.
    - 특정 상황(시스템 콜이 발생하거나, exception이나 인터럽트가 발생한 경우)에 CPU는 모드를 변경한다.
2. base register와 bounds register
    - 각 CPU는 추가적인 레지스터 한 쌍을 더 가지고 있는데, 이 레지스터 쌍은 CPU의 MMU의 일부이다.
    - 사용자 프로그램이 실행되고 있을 때, 하드웨어는 사용자 프로그램에 의해 생성된 가상 주소에 베이스 값을 더해서 주소를 변환한다.
    - 하드웨어는 주소가 유효한지를 확인할 수 있어야 하는데, bounds register를 사용해서 확인한다.
3. base register와 bounds register를 수정하기 위한 특별한 instruction
    - 서로 다른 프로세스들이 실행될 때, OS가 레지스터를 수정할 수 있어야 한다.
    - 이 instruction은 커널 모드에서만 실행될 수 있다.
4. CPU는 사용자 프로그램이 메모리에 잘못된 접근을 하려고 할 경우 exception을 발생시킬 수 있어야 한다.
    - 예: 범위를 벗어난 주소에 접근하려는 경우
    - 이런 경우 CPU는 사용자 프로그램의 실행을 정지하고, OS가 "out of bounds" exception handler를 실행하도록 해야 한다. 그러면 OS handler는 어떤 방식으로 대응해야 할 지를 결정한다 (이 경우 프로세스를 종료할 가능성이 높음).
    - 사용자 프로그램이 커널 영역의 base register와 bounds register 내의 값을 변경하려고 하면, CPU는 exception을 발생시키고 "tried to execute a privileged operation while in user mode" handler를 실행한다.
    - CPU는 각 handler의 위치를 알려주는 메서드를 제공할 수 있어야 한다 (privileged instruction으로 제공).

## 15.5 Operating System Issues

dynamic relocation을 지원하기 위해 하드웨어가 새로운 기능을 제공하는 것처럼, OS도 처리해야 할 것들이 있다.
1. 프로세스가 생성되었을 때, 메모리에서 해당 프로세스의 주소 공간을 위한 공간을 찾아야 한다.
    - 새로운 프로세스가 생성되면 새로운 주소 공간을 위한 공간을 찾기 위해 OS는 **free list**라고 불리는 데이터 구조를 찾는다.
        - free list에는 비어있는 주소 공간들이 어디인지가 담겨있다.
    - 주소 공간의 크기가 가변적인 경우 더 복잡해진다.
2. 프로세스가 종료되었을 때, 메모리를 다시 뺏어와야 한다.
    - 프로세스가 종료되면 그 프로세스가 사용했던 메모리를 다시 free list에 추가한다.
3. 문맥 교환이 일어났을 경우 추가적으로 해야할 것들
    - 각 CPU에는 한 쌍의 base register와 bounds register만 존재하고, 실행중인 프로그램 마다 base/bounds 레지스터의 값이 다르다. 각 프로그램은 각각 다른 물리 주소에 로드되기 때문이다.
    - OS는 프로세스를 변경할 때(문맥 교환이 발생할 때) 메모리에 base/bounds 레지스터의 값을 저장해야 하는데, **Proces Control Block(PCB)**에 저장한다.
    - 실행 중인 프로세스를 재개하거나, 프로세스를 처음으로 실행할 때, OS는 base/bounds register의 값을 CPU에 설정해야 한다.
    - 프로세스의 실행이 중단되었을 때(실행되고 있지 않을 때), OS는 비교적 쉽게 주소 공간을 메모리의 다른 곳으로 이동시킬 수 있다.
        - 프로세스의 주소 공간을 이동하기 위해서는 우선 OS는 프로세스를 deschedule해야 한다.
        - 그 다음, OS는 주소 공간을 현재의 위치에서 이동시킬 위치로 복사한다.
        - 마지막으로, OS는 저장된 base register를 PCB에 업데이트 한다.
        - 그 프로세스가 재개되면, 새로운 base register 값이 복원되고 프로세스가 다시 실행된다.
4. exception handler를 제공해야 한다.
    - OS는 exception handler들을 부팅할 때 인스톨한다.
    - exception handler란?
        - 예: 프로세스가 자신의 범위 밖의 메모리에 접근하려고 하면, CPU가 exception을 발생시킨다. exception handler는 이런 exception이 발생했을 때 실행되는 함수 같은 것임.

## 15.6 Summary
dynamic relocation의 비효율성
- **internal fragmentation**: 물리 메모리에 프로세스를 위해 할당된 공간이 다 쓰이지 않는 것 (힙~스택 사이의 할당된 공간이 쓰이지 않을 때 발생). 현재의 가정은 물리 메모리에 공간을 할당할 때 정해진 크기를 할당하기 때문에 이 문제가 발생한다.
- 이 문제를 해결하기 우해서는 **segmentation**을 사용한다.
