# 16 Segmentation

## 16.1 Segmentation: Generalized Base/Bounds
**segmentation**: base/bound 쌍을 MMU에서 1개만 가지고 있는 게 아니라, 주소 공간의 각 부분(segment)마다 가진다면 어떨까?
- segment: 특정 길이 만큼의 주소 공간.
- 논리적으로 코드/스택/힙 3개의 segment로 구분되어 있는 주소 공간의 경우, 각 세그먼트를 물리 메모리의 각각 다른 부분에 저장해서 사용하지 않는 가상 메모리 주소가 물리 메모리를 낭비하는 것을 방지하기
    - 이 경우에는 MMU의 하드웨어 구조는 3쌍의 base/bounds 레지스터 쌍을 가진다.
    - bounds 레지스터는 세그먼트의 크기를 값으로 갖는다.
- **segmentation fault**: 범위 바깥의 주소에 접근하려고 하면 발생

## 16.3 What About The Stack?
스택은 가상 메모리에서는 높은 주소 -> 낮은 주소로 커졌지만, relocate된 물리 주소에서는 낮은 주소 -> 높은 주소로 커진다. 스택을 물리 주소로 변환하기 위해서는 base/bounds 값 외에 어느 방향으로 segment가 커지는 지 알려주는 값이 하나 필요하다.
- 예: 커지는 방향(위/아래)를 알려주는 비트를 1개 사용하기

## 16.4 Support for Sharing
주소 공간들 간에 특정 메모리 세그먼트를 공유하는 것
공유가 가능하게 하려면, **protection bit**을 하드웨어에서 지원해야 한다.
- 프로그램이 세그먼트를 읽거나 쓸 수 있는지를 알려주는 비트를 추가

## 16.5 Fine-grained vs Coarse-grained Segmentation
세그먼트가 많아지면(세그먼트를 잘게 쪼개면), 메모리에 **segment table**이 저장되어 있어야 한다.

## 16.6 OS Support
세그먼트의 크기가 변하면 어떻게 해야 할까?
- 예: 힙 세그먼트가 커질 경우
    - 메모리 할당 라이브러리가 힙을 키우라는 시스템 콜을 수행한다.
    - OS는 세그먼트 사이즈 레지스터를 더 큰 값으로 업데이트 해서 더 많은 공간을 제공하고, 라이브러리에 성공했다고 알려준다.
    - 그러면 라이브러리는 새로운 객체를 위한 공간을 할당할 수 있고, 호출한 프로그램에게 성공을 반환할 수 있다.
    - OS가 힙을 키워달라는 요청을 거절할 수도 있다 (물리 메모리 공간이 부족한 경우 또는 요청한 프로세스가 이미 메모리를 너무 많이 차지하고 있다고 판단한 경우).

물리 메모리의 빈 공간을 어떻게 관리해야 할까?
- 새로운 주소 공간이 생성되면 OS는 그 주소 공간의 세그먼트를 위해서 물리 메모리에서 공간을 찾아야 한다.
- **external fragmentation**: 물리 메모리에 할당되지 않은 빈 공간이 여기저기 조금씩 존재해서 새로운 세그먼트를 할당하거나 기존 세그먼트의 크기를 키울 수 없는 문제
    - 예: 빈 공간이 24KB 있지만 연속된 공간이 아니기 때문에 20KB짜리 세그먼트를 할당할 수 없게 되는 경우
- 외부 단편화 해결 방안
    - 기존의 세그먼트를 재정렬해서 물리 메모리를 compact하는 방법
        - 실행 중인 프로세스들을 멈추고, 데이터를 메모리 상의 연속적인 영역에 복사하고 세그먼트 레지스터 값을 새로운 물리 주소 값으로 변경한다.
        - 다만 이 해결방안은 expensive하다. 세그먼트를 복사하는 것이 memory-intensive하며, 프로세서 시간을 꽤 많이 사용하기 때문이다.
        - compact하고 나서 세그먼트 크기를 키우기도 어렵게 된다.
    - free-list management algorithm을 사용하는 방법
        - best-fit(최적적합): 요구한 크기랑 가장 비슷한 크기를 가진 곳에 할당
        - worst-fit(최악적합): 제일 큰 곳에 할당
        - first-fit: 제일 처음으로 가능한 크기인 곳에 할당
        - buddy algorithm: ?

## 16.7 Summary
가변적인 크기의 세그먼트를 메모리에 할당할 때 발생할 수 있는 문제 (세그멘테이션 기법의 문제)
1. 외부 단편화
    - 가용 가능한 메모리(빈 메모리)가 각각 다른 크기의 조각들로 쪼개지기 때문에, 메모리 할당 요청을 만족시키기 어려울 수 있다. 알고리즘을 사용하거나 주기적으로 메모리를 compact할 수 있지만, 근본적인 문제 자체를 회피하기는 어렵다.
2. 충분히 flexible하지는 못하다.
    - 예: 하나의 논리적인 세그먼트 내에 크고, 조금씩만 쓰이는 힙을 가지고 있을 경우, 힙에 접근하기 위해 힙 전체가 메모리에 있어야만 한다.

## Homework
1. 주소 변환하기
    - 첫번째거
        - VA0: 128 - 20 = 108 이므로 seg1에 유효 (decimal: 512 - 20 = 492)
        - 나머지: fault
    - 두번째거
        - VA0: seg0 (decimal: 17)
        - VA1: seg1 (decimal: 492)
        - 나머지: fault
    - 세번째거
        - VA0: seg1 (decimal: 506)
        - VA1: seg1 (decimal: 505)
        - VA2: seg0 (decimal: 7)
        - VA3: seg0 (decimal: 10)
        - VA4: fault

3. address size = 16, 피지컬 메모리 = 128
    - b0: 0 (decimal: 0), l0: 2, b1: 15 (decimal: 14), l1: 2
    - ![](https://i.imgur.com/mSNwZuu.png)

4. 90% 정도가 valid하게 하려면 어떻게 해야 할까?
    - b0: 0, b1: max 값으로 설정하고, 각각의 l을 45% 값으로 설정
