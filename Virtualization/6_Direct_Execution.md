# 6 Direct Execution

CPU를 가상화하기 위해서 OS는 동시에 실행되는 것처럼 보이는 여러 작업 간에 물리적인 CPU를 어떻게든 공유해야 한다.
→ 하나의 프로세스를 잠깐동안 실행하고, 다른 프로세스를 잠깐 실행하고, 하는 식으로 CPU를 time-sharing 하는 방식으로 가상화를 한다.

이런 가상화 방식에서 OS의 도전과제: 컨트롤을 유지하면서 높은 퍼포먼스를 내는 것!
1. Peformance: 시스템에 오버헤드를 지나치게 발생시키지 않으면서 가상화를 구현하려면 어떻게 해야 할까?
2. Control: CPU에 대한 컨트롤을 유지하면서 프로세스를 어떻게 효율적으로 실행할 수 있을까?
    - OS가 리소스를 관리하기 때문에 OS에게 있어 컨트롤은 매우 중요하다. 컨트롤이 없으면 하나의 프로세스가 영원히 실행될 수도 있고, 접근해서는 안 되는 정보에 접근할 수도 있다.

## 6.1 Limited Direct Execution

프로그램을 빨리 실행하기 위해서 **Limited Direct Execution** 기술을 만들었다.
- direct execution: 프로그램을 CPU에서 직접 실행하는 것.
  - OS가 프로그램을 실행하고 싶을 때 프로세스 리스트에 프로세스 entry를 생성하고 → 그 프로세스 엔트리에 메모리를 할당하고 → 디스크로부터 메모리에 프로그램 코드를 로드하고 → 프로그램의 엔트리 포인트(예: `main()`)를 찾아내고 → 코드를 실행하기 시작한다.
  - direct execution의 문제점
    - 프로그램을 실행했을 때, 프로그램이 의도된 동작 외에 다른것들을 하지 않으면서 효율적으로 실행될 수 있도록 OS가 확신할 수 있는 방법이 있을까?
    - 프로세스를 실행하고 있을 때, OS는 프로그램을 어떻게 중지하고 다른 프로세스로 전환해서 CPU 가상화를 위한 time sharing을 구현할 수 있을까?
    
    → 실행중인 프로그램에 제약(limit)을 줘서 OS가 컨트롤을 가질 수 있게 한다.
    
## 6.2 Problem 1: Restricted Operations
Direct Execution은 하드웨어 CPU에서 바로 실행되기 때문에 빠르다는 장점이 있다.
  - CPU에서 직접 실행되었을 때의 문제점: 프로세스가 제한된(restricted) 작업을 수행하고자 하거나, 더 많은 시스템 리소스(CPU나 메모리)에 대한 접근을 얻고 싶어 할 수도 있다.
  - 이걸 해결하기 위해서 새로운 프로세서 모드인 **user mode**가 소개되었다.

user mode에서 실행되는 코드는 할 수 있는 것이 제한되어 있다.
  - 하드웨어 리소스에 대한 full access를 가지고 있지 않다.
  - 예를 들어, 유저 모드에서 실행되는 프로세스는 I/O 요청을 발행할 수 없다. I/O 요청을 발행하면 프로세서가 exception을 일으키고, OS가 프로세스를 죽여버릴 것이다.
 
user mode와 반대되는 모드는 **kernel mode**이다.
  - 커널 모드에서 OS가 실행된다.
  - 커널 모드에서는 하고싶은 거 다 할 수 있다. (모든 리소스에 대한 접근 권한이 있다.)

유저 프로세스가 할 수 없는 일을 하고싶을 때에는 어떻게 해야 할까?
  - 유저 프로그램이 **system call**을 수행할 수 있는 능력을 제공한다.
  - 시스템 콜은 커널이 유저 프로그램에게 일정 기능을 노출하는 것을 허용해준다.

## 6.2 Problem 2: Switching Between Processes

프로세스 간에 전환을 어떻게 할 것인가?
  - 프로세스가 CPU에서 실행되고 있다는 것은, OS는 실행되지 않고 있다는 것이다. OS가 실행되지 않고 있는데 OS가 어떻게 프로세스를 전환시킬 수 있는가? OS가 CPU에 대한 컨트롤을 어떻게 가져와서 프로세스를 전환할 것인가?
 
 Cooperative Approach: 시스템 콜을 기다리기
  - OS는 시스템의 프로세스가 타당하게 행동할거라고 믿는다.
    - 지나치게 오래 실행되는 프로세스들은 주기적으로 CPU를 포기해서 OS가 다른 작업을 실행할 수 있도록 한다.
    - 대부분의 프로세스는 시스템 콜을 만들어서 꽤 자주 CPU에 대한 컨트롤을 OS에게 넘겨준다.
    - 이런 시스템은 종종 **yield** 시스템 콜을 포함하고 있다. yield는 OS에게 컨트롤을 넘겨서 OS가 다른 프로세스를 실행할 수 있도록 하는 일만 한다.
    - 앱이 허용되지 않은 짓을 했을 때에도 OS에게 컨트롤을 넘겨준다. 예를 들어 접근하면 안되는 메모리에 접근하려고 할 경우, 앱은 OS에 **trap**을 발생시킨다. 그러면 OS는 CPU에 대한 컨트롤을 다시 갖게 된다.
  - Cooperative Scheduling System 하에서는 OS는 시스템 콜을 기다리거나 비허용된 접근이 일어나기를 기다려야만 CPU에 대한 컨트롤을 다시 얻을 수 있다. 상당히 수동적이다.

Non-Cooperative Approach: OS가 컨트롤을 가져오기
  - **timer interrupt**: 일정 시간마다 인터럽트를 발생시켜서 현재 실행중인 프로세스를 멈추고, OS의 미리 설정된 **interrupt handler**가 실행된다. 이 때 OS가 CPU에 대한 컨트롤을 다시 얻고, OS가 하고싶은 걸 할 수 있다(현재의 프로세스를 멈추고 다른 프로세스를 시작)
    - OS는 하드웨어에게 타이머 인터럽트가 발생하면 어떤 코드를 실행해야 하는지 알려줘야 한다. 부팅할 때 알려준다.
    - 부팅 과정 중에 OS는 타이머를 시작시켜야 한다(privileged operation).
    - 타이머를 끌 수도 있다(previleged operation) → 컨커런시 관련 내용
  - 인터럽트가 발생하면 하드웨어는 실행되던 프로그램의 상태를 저장해야 할 책임이 있다 (그 프로그램을 다시 잘 실행 할 수 있도록).
 
 Saving and Restoring Context
  - OS가 컨트롤을 다시 갖게 되면 OS는 현재 실행 중인 프로세스를 계속 실행할 지, 새로운 프로세스로 전환할 지 결정해야 한다. 이 결정은 OS의 **스케줄러**가 내린다.
    - 프로세스를 전환하는 결정을 내리면, OS는 **context switch**를 실행한다.
    - context switch: 현재 실행중인 프로세스의 일부 레지스터 값을 커널 스택에 저장하고, 실행 할 프로세스의 레지스터 값을 복원하는 것
  - 현재 실행 중인 프로세스의 context를 저장하기 위해서 OS는 현재 실행중인 프로세스의 general purpose registers, PC(Program Counter), 커널 스택 포인터를 저장하고, 실행 할 프로세스의 저것들을 복원한다.
    - 프로그램 카운터: 현재 프로세스 중에서 처리되고 있는 명령어가 무엇인지, 다음번에 실행할 명령어가 무엇인지 위치를 가리키는 것
  - 스택을 전환함으로써(스택 포인터를 실행할 프로세스의 커널 스택으로 바꿔서) context를 전환한다. 커널은 인터럽트 된 프로세스의 컨텍스트의 switch code 호출에 들어가고, 실행될 프로세스의 context로 return된다.
  - OS가 return-from-trap instruction을 실행하면 실행 예정인 프로세스가 현재 실행중인 프로세스가 되어 context switch가 완료된다.
  - 이 과정에서 두 종류의 레지스터 저장/복원이 일어난다.
    - 타이머 인터럽트가 발생했을 때: 실행중인 프로세스의 user register는 하드웨어에 의해 해당 프로세스의 커널 스택을 사용해서 암시적으로 저장된다.
    - OS가 프로세스를 전환하기로 결정했을 때: 커널 레지스터는 명시적으로 소프트웨어(예: OS)에 의해 그 프로세스의 프로세스 구조 안에 있는 메모리에 저장된다.

## 6.4 Concurrency

시스템 콜 중에 타이머 인터럽트가 발생하면 어떻게 될까? 아니면 인터럽트를 처리하고 있을 때 다른 인터럽트가 발생하면 어떻게 될까?
  - concurrency에 관한 문제
  - OS는 내부 데이터 구조에 동시적으로 접근하는 것을 보호하기 위한 다양한 locking scheme을 가지고 있어서, 커널 내에서 동시에 여러가지 activity가 가능하게 해준다. 이는 멀티프로세서에서 특히 유용하다.
