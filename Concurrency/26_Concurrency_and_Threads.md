# 26 Concurrency and Threads

멀티 스레드 프로그램: 실행 지점이 하나 이상이다
- 같은 주소 공간을 공유하기 때문에 서로 다른 스레드에서 같은 데이터에 접근할 수 있다.
- 하나의 스레드의 상태는 하나의 프로세스의 상태와 매우 유사하다.
    - 스레드의 상태는 프로그램이 어디에서 instruction을 받아오고 있는지를 트래킹하는 프로그램 카운터(PC)를 가지고 있다.
    - 각 스레드는 연산에 사용하는 자신만의 private한 레지스터 집합을 가지고 있다. 따라서 하나의 프로세서에서 두 개의 스레드가 실행 되고 있다면, 실행 중인 스레드를 다른 스레드로 교체하기 위해서는 문맥 교환이 일어나야 한다.
    - 스레드간의 문맥 교환은 프로세스간의 문맥 교환과 유사하다. 문맥 교환을 위해서는 스레드1의 레지스터 상태를 **Thread Control Block**(**TCB**)에 저장하고, 스레드2의 레지스터 상태를 TCB에서 복원해야 한다.
    - 프로세스간의 문맥 교환과의 차이점은 주소 공간이 동일하기 때문에 사용 중인 페이지 테이블을 교체할 필요가 없다는 것이다.
- 프로세스와 스레드의 큰 차이점 중 하나는 스택과 관련이 있다.
    ![](https://i.imgur.com/Vj4hjhI.png)
    - 싱글 스레드 프로세스는 스택이 주소 공간 아래쪽에 하나만 존재한다.
    - 멀티 스레드 프로세스는 각 스레드가 독립적으로 실행되기 때문에 주소 공간에 스레드 하나마다 스택이 하나씩 존재하게 된다. 따라스 스택에 할당되는 변수, 매개변수, 반환값 등은 연관된 스레드의 스택(thread-local 저장소라고도 불림)에 저장된다.
    - 싱글 스레드 프로세스는 스택과 힙이 각각 커져서 주소 공간이 부족해 졌을 때에만 문제가 생겼지만, 멀티 스레드 프로세스는 좀 더 복잡해진다. 하지만 보통 스택은 아주 클 필요가 없기 때문에 문제가 자주 발생하지는 않는다.

## 26.1 Why Use Threads?

1. Parallelism (병렬성)
    - 각 CPU마다 하나의 스레드를 사용해서 여러 개의 CPU가 하나의 작업을 수행해서 더 빠르게 할 수 있다.

2. 느린 입출력에 의해 프로그램의 진행이 block 되는 것을 피하기 위해서
    - 한 스레드에서 입출력 작업을 기다리는 동안, CPU 스케줄러는 다른 스레드로 문맥 교환을 해서 그 스레드의 작업을 실행할 수 있다.

멀티 스레딩 대신에 멀티 프로세싱을 사용할 수도 있지만, 스레드는 주소 공간을 공유하기 때문에 데이터를 공유하기 더 쉽다.

## 26.2 An Example: Thread Creation

먼저 생성된 스레드라고 해서 꼭 먼저 실행되지는 않는다. 다음에 실행될 스레드는 OS Scheduler에 의해 결정된다.
시스템은 호출되는 루틴을 실행할 스레드를 생성하고, 그 스레드는 호출자와는 독립적으로 실행된다 (스레드 생성으로부터 return하기 전에 실행될 수도 있고, return 하고 한참 후에 실행될 수도 있다).
→ 언제 어떤 스레드가 실행될 지 알기가 너무 어렵다.

## 26.3 Shared Data

공유 데이터에 여러 개의 스레드가 접근하면 스레드간에 어떻게 상호작용 할까?
- 예: 두 개의 스레드가 하나의 공유된 전역 변수를 업데이트 하려는 경우
    - 가정1: 스레드 생성을 래핑하고 루틴을 합쳐서 실패하면 exit 시킨다. 에러가 발생하면 에러가 발생했다고 알려주기만 하고(print), 다른 처리 안함. 정상적으로 생성된 경우의 return code = 0.
    - 가정2: 각 스레드별로 다른 함수 구현부를 사용하지 않고, 하나의 코드를 공통적으로 사용하고 스레드별로 인자를 다르게 넘겨준다.
    - 가정3: 각 스레드가 하려는 일은 공유 변수인 `counter`에 숫자를 더하고, 이걸 천만번 반복한다. → 원하는 결과값: counter = 20,000,000
    - 예제 코드를 실행하면 결과값이 원하는대로 나오지 않는다 (실행할 때마다 다른 결과값이 나온다).


## 26.4 Uncontrolled Scheduling

위 예시에서 어떤 문제가 발생할 수 있는지 알아보자. `counter`의 값이 50인 시점이라고 가정해보자.
- 스레드1이 `counter`의 값(`50`)을 자신의 레지스터 `eax`에 로드한다.
- 스레드1이 자신의 레지스터에 +1 한다 (`eax = 51`).
- 타이머 인터럽트가 발생해서 OS는 현재 실행중인 스레드1의 상태를 스레드1의 TCB에 저장한다.
- 스레드2가 실행된다. 스레드2는 `counter`의 값(`50`)을 자신의 레지스터 `eax`에 로드한다.
- 스레드2가 자신의 레지스터에 +1 한다 (`eax = 51`).
- 스레드2가 레지스터의 값을 `counter`에 저장한다. 이제 전역 변수 `counter`의 값은 `51`이 된다.
- 문맥 교환이 일어나서 스레드1이 다시 실행된다. 스레드 1은 값을 +1 하는 instruction까지 실행을 마쳤기 때문에, `counter`에 자신의 레지스터 값을 저장하는 instruction을 실행한다 (`counter = 51`).

→ `counter`에 수를 더하는 코드가 두 번 실행되었지만, 실제로 `counter`의 값은 1만 증가했다. 이 상황을 **Race Condition**(**경쟁 상태**)이라고 한다. 코드가 실행되는 타이밍에 따라 결과가 달라진다.
여러 개의 스레드가 해당 코드를 실행하면 경쟁 상태가 발생할 수 있는 코드를 **Critical Section**(**임계 구역**)이라고 한다. 임계 구역은 공유된 변수(공유 자원)에 접근하는 코드를 의미하며, 한 번에 여러 개의 스레드에서 동시적으로 실행하면 안 된다.
이 코드에는 **Mutual Exclusion**(**상호 배제**)이 필요하다. 상호 배제는 한 스레드가 임계 구역 내의 코드를 실행하고 있으면, 다른 스레드가 임계 구역의 코드를 사용하는 것을 막는다.

## 26.5 The Wish for Atomicity

atomic operation
- 여러 개의 action을 atomic하게 만든다는 것은, action 전체가 일어나거나 action 전체가 일어나지 않는다는 것을 의미한다 (몇 개만 일어나는 상황은 없음)
- transaction: 여러 개의 action을 하나의 atomic action으로 그루핑하는 것

위의 문제를 해결하기 위해서는 때에 맞지 않는 인터럽트의 발생 가능성을 없애는 instruction을 추가하는 방법이 있다.
- 예: `memory-add 0x80491ac, $0x1` (메모리 위치에 값을 더하는 instruction)
    - 하드웨어가 위의 instruction이 atomic하게 실행되는 것을 보장한다고 가정한다.
        → 이 instruction이 실행되면 원하는 대로 값이 업데이트 되는 것을 보장한다 (atomic 하다는 것은 instruction의 중간에 방해받을 수 없다는 것을 의미하기 때문).
        - 만약 인터럽트가 발생하면 instruction이 아예 실행되지 않거나 끝까지 실행된다. 실행 도중에 그만두지는 않는다.

→ `counter`의 값을 레지스터로 로드하는 instruction, 레지스터의 값에 +1하는 instruction, 레지스터의 값을 `counter`에 저장하는 instruction의 시퀀스를 atomic하게 실행해야 한다.

임계 구역에 동기적으로, 통제 하에 접근하도록 하는 멀티 스레딩 된 코드를 만들어서 동시적으로 실행되도 올바른 결과값을 얻는 것을 보장하도록 해야 한다.

동기화(synchronization)을 어떻게 구현할 수 있을까?


## 26.6 Waiting For Another

동시성이 유발하는 문제
- 스레드 간에 일어나는 상호작용 중 공유 자원에 접근하고 임계 구역을 atomic하게 만들어야 한다는 것 (이 챕터에서 나온 것)
- 어떤 스레드가 다른 스레드가 어떤 action을 완료할 때까지 기다린 후 실행을 재개할 수 있는 경우
    - 예: 어떤 프로세스가 디스크 입출력을 수행하고, sleep 상태가 된 경우
        - 입출력 작업이 끝나면 프로세스를 다시 깨워서 재개해야 한다.
